-- Add speech parsing logs table
CREATE TABLE IF NOT EXISTS speech_parsing_logs (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    input_text TEXT NOT NULL,
    language VARCHAR(5) DEFAULT 'en',
    context VARCHAR(50) DEFAULT 'menu_creation',
    parsed_data JSONB DEFAULT '{}',
    confidence_score DECIMAL(3,2) DEFAULT 0.0,
    processing_time_ms INTEGER DEFAULT 0,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add ingredient creation logs table
CREATE TABLE IF NOT EXISTS ingredient_creation_logs (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    input_ingredients TEXT[] NOT NULL,
    language VARCHAR(5) DEFAULT 'en',
    context JSONB DEFAULT '{}',
    created_count INTEGER DEFAULT 0,
    existing_count INTEGER DEFAULT 0,
    failed_count INTEGER DEFAULT 0,
    processing_time_ms INTEGER DEFAULT 0,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_speech_parsing_logs_user_id ON speech_parsing_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_speech_parsing_logs_timestamp ON speech_parsing_logs(timestamp);
CREATE INDEX IF NOT EXISTS idx_speech_parsing_logs_language ON speech_parsing_logs(language);
CREATE INDEX IF NOT EXISTS idx_speech_parsing_logs_confidence ON speech_parsing_logs(confidence_score);

CREATE INDEX IF NOT EXISTS idx_ingredient_creation_logs_user_id ON ingredient_creation_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_ingredient_creation_logs_timestamp ON ingredient_creation_logs(timestamp);
CREATE INDEX IF NOT EXISTS idx_ingredient_creation_logs_language ON ingredient_creation_logs(language);

-- Enable RLS
ALTER TABLE speech_parsing_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE ingredient_creation_logs ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY "Users can view own speech parsing logs" ON speech_parsing_logs
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own speech parsing logs" ON speech_parsing_logs
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can view own ingredient creation logs" ON ingredient_creation_logs
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own ingredient creation logs" ON ingredient_creation_logs
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Add parsing analytics functions
CREATE OR REPLACE FUNCTION get_speech_parsing_analytics(user_id UUID)
RETURNS TABLE (
    total_parses BIGINT,
    avg_confidence DECIMAL,
    most_common_language VARCHAR(5),
    parses_today BIGINT,
    parses_this_week BIGINT,
    parses_this_month BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_parses,
        AVG(confidence_score) as avg_confidence,
        MODE() WITHIN GROUP (ORDER BY language) as most_common_language,
        COUNT(*) FILTER (WHERE timestamp >= DATE_TRUNC('day', NOW())) as parses_today,
        COUNT(*) FILTER (WHERE timestamp >= DATE_TRUNC('week', NOW())) as parses_this_week,
        COUNT(*) FILTER (WHERE timestamp >= DATE_TRUNC('month', NOW())) as parses_this_month
    FROM speech_parsing_logs 
    WHERE speech_parsing_logs.user_id = get_speech_parsing_analytics.user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add ingredient creation analytics function
CREATE OR REPLACE FUNCTION get_ingredient_creation_analytics(user_id UUID)
RETURNS TABLE (
    total_operations BIGINT,
    total_ingredients_created BIGINT,
    total_ingredients_processed BIGINT,
    success_rate DECIMAL,
    operations_today BIGINT,
    operations_this_week BIGINT,
    operations_this_month BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_operations,
        SUM(created_count) as total_ingredients_created,
        SUM(created_count + existing_count + failed_count) as total_ingredients_processed,
        CASE 
            WHEN SUM(created_count + existing_count + failed_count) > 0 
            THEN (SUM(created_count + existing_count)::DECIMAL / SUM(created_count + existing_count + failed_count)) * 100
            ELSE 0::DECIMAL
        END as success_rate,
        COUNT(*) FILTER (WHERE timestamp >= DATE_TRUNC('day', NOW())) as operations_today,
        COUNT(*) FILTER (WHERE timestamp >= DATE_TRUNC('week', NOW())) as operations_this_week,
        COUNT(*) FILTER (WHERE timestamp >= DATE_TRUNC('month', NOW())) as operations_this_month
    FROM ingredient_creation_logs 
    WHERE ingredient_creation_logs.user_id = get_ingredient_creation_analytics.user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get popular parsed dishes
CREATE OR REPLACE FUNCTION get_popular_parsed_dishes(user_id UUID DEFAULT NULL, limit_count INTEGER DEFAULT 10)
RETURNS TABLE (
    dish_name TEXT,
    parse_count BIGINT,
    avg_confidence DECIMAL,
    languages TEXT[],
    last_parsed TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        (parsed_data->>'name')::TEXT as dish_name,
        COUNT(*) as parse_count,
        AVG(confidence_score) as avg_confidence,
        ARRAY_AGG(DISTINCT language) as languages,
        MAX(timestamp) as last_parsed
    FROM speech_parsing_logs 
    WHERE (get_popular_parsed_dishes.user_id IS NULL OR speech_parsing_logs.user_id = get_popular_parsed_dishes.user_id)
      AND parsed_data->>'name' IS NOT NULL
      AND parsed_data->>'name' != ''
    GROUP BY parsed_data->>'name'
    ORDER BY parse_count DESC, avg_confidence DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get ingredient creation patterns
CREATE OR REPLACE FUNCTION get_ingredient_creation_patterns(user_id UUID DEFAULT NULL, limit_count INTEGER DEFAULT 20)
RETURNS TABLE (
    ingredient_name TEXT,
    creation_count BIGINT,
    contexts JSONB,
    languages TEXT[],
    last_created TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        UNNEST(input_ingredients)::TEXT as ingredient_name,
        COUNT(*) as creation_count,
        JSONB_AGG(DISTINCT context) as contexts,
        ARRAY_AGG(DISTINCT language) as languages,
        MAX(timestamp) as last_created
    FROM ingredient_creation_logs 
    WHERE (get_ingredient_creation_patterns.user_id IS NULL OR ingredient_creation_logs.user_id = get_ingredient_creation_patterns.user_id)
    GROUP BY UNNEST(input_ingredients)
    ORDER BY creation_count DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add cleanup function for old logs (for maintenance)
CREATE OR REPLACE FUNCTION cleanup_old_parsing_logs(days_to_keep INTEGER DEFAULT 90)
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    -- Delete old speech parsing logs
    DELETE FROM speech_parsing_logs 
    WHERE created_at < NOW() - INTERVAL '1 day' * days_to_keep;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    -- Delete old ingredient creation logs
    DELETE FROM ingredient_creation_logs 
    WHERE created_at < NOW() - INTERVAL '1 day' * days_to_keep;
    
    GET DIAGNOSTICS deleted_count = deleted_count + ROW_COUNT;
    
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add function to validate parsed dish data
CREATE OR REPLACE FUNCTION validate_parsed_dish_data(parsed_data JSONB)
RETURNS BOOLEAN AS $$
BEGIN
    -- Check required fields
    IF parsed_data->>'name' IS NULL OR LENGTH(TRIM(parsed_data->>'name')) = 0 THEN
        RETURN FALSE;
    END IF;
    
    -- Check ingredients array exists
    IF parsed_data->'ingredients' IS NULL OR JSONB_ARRAY_LENGTH(parsed_data->'ingredients') = 0 THEN
        RETURN FALSE;
    END IF;
    
    -- Check confidence score is valid
    IF (parsed_data->>'confidence_score')::DECIMAL < 0 OR (parsed_data->>'confidence_score')::DECIMAL > 1 THEN
        RETURN FALSE;
    END IF;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;