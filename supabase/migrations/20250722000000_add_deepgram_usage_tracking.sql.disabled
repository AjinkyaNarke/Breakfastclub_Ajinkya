-- Add Deepgram usage tracking to profiles table
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS deepgram_usage_quota INTEGER DEFAULT NULL;
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS deepgram_usage_current DECIMAL(10,2) DEFAULT 0;
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS deepgram_usage_reset_date TIMESTAMPTZ DEFAULT NULL;

-- Create Deepgram usage logs table
CREATE TABLE IF NOT EXISTS deepgram_usage_logs (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    duration DECIMAL(10,2) NOT NULL DEFAULT 0, -- Duration in minutes
    model VARCHAR(50) DEFAULT 'nova-2',
    feature VARCHAR(50) DEFAULT 'listen',
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create index for efficient queries
CREATE INDEX IF NOT EXISTS idx_deepgram_usage_logs_user_id ON deepgram_usage_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_deepgram_usage_logs_timestamp ON deepgram_usage_logs(timestamp);
CREATE INDEX IF NOT EXISTS idx_deepgram_usage_logs_user_timestamp ON deepgram_usage_logs(user_id, timestamp);

-- Create function to increment user's Deepgram usage
CREATE OR REPLACE FUNCTION increment_deepgram_usage(user_id UUID, amount DECIMAL)
RETURNS VOID AS $$
BEGIN
    UPDATE profiles 
    SET deepgram_usage_current = COALESCE(deepgram_usage_current, 0) + amount
    WHERE id = user_id;
    
    -- If no row was updated, the user doesn't exist in profiles yet
    IF NOT FOUND THEN
        INSERT INTO profiles (id, deepgram_usage_current)
        VALUES (user_id, amount)
        ON CONFLICT (id) DO UPDATE SET
            deepgram_usage_current = COALESCE(profiles.deepgram_usage_current, 0) + amount;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to reset monthly usage
CREATE OR REPLACE FUNCTION reset_monthly_deepgram_usage()
RETURNS VOID AS $$
BEGIN
    UPDATE profiles 
    SET deepgram_usage_current = 0,
        deepgram_usage_reset_date = NOW()
    WHERE deepgram_usage_reset_date IS NULL 
       OR deepgram_usage_reset_date < DATE_TRUNC('month', NOW());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to get user's usage summary
CREATE OR REPLACE FUNCTION get_deepgram_usage_summary(user_id UUID)
RETURNS TABLE (
    current_usage DECIMAL,
    quota INTEGER,
    remaining DECIMAL,
    usage_this_month DECIMAL,
    usage_today DECIMAL,
    last_reset TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.deepgram_usage_current,
        p.deepgram_usage_quota,
        CASE 
            WHEN p.deepgram_usage_quota IS NOT NULL 
            THEN p.deepgram_usage_quota - COALESCE(p.deepgram_usage_current, 0)
            ELSE NULL::DECIMAL
        END as remaining,
        COALESCE(
            (SELECT SUM(duration) 
             FROM deepgram_usage_logs 
             WHERE deepgram_usage_logs.user_id = get_deepgram_usage_summary.user_id 
               AND timestamp >= DATE_TRUNC('month', NOW())), 
            0
        ) as usage_this_month,
        COALESCE(
            (SELECT SUM(duration) 
             FROM deepgram_usage_logs 
             WHERE deepgram_usage_logs.user_id = get_deepgram_usage_summary.user_id 
               AND timestamp >= DATE_TRUNC('day', NOW())), 
            0
        ) as usage_today,
        p.deepgram_usage_reset_date
    FROM profiles p
    WHERE p.id = get_deepgram_usage_summary.user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create RLS policies
ALTER TABLE deepgram_usage_logs ENABLE ROW LEVEL SECURITY;

-- Users can only see their own usage logs
CREATE POLICY "Users can view own usage logs" ON deepgram_usage_logs
    FOR SELECT USING (auth.uid() = user_id);

-- Users can insert their own usage logs
CREATE POLICY "Users can insert own usage logs" ON deepgram_usage_logs
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Create rate limiting table
CREATE TABLE IF NOT EXISTS deepgram_rate_limits (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    endpoint VARCHAR(100) NOT NULL,
    request_count INTEGER DEFAULT 1,
    window_start TIMESTAMPTZ DEFAULT NOW(),
    window_size_minutes INTEGER DEFAULT 60,
    max_requests INTEGER DEFAULT 100,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create unique index for rate limiting
CREATE UNIQUE INDEX IF NOT EXISTS idx_deepgram_rate_limits_user_endpoint 
ON deepgram_rate_limits(user_id, endpoint, window_start);

-- Create function to check rate limit
CREATE OR REPLACE FUNCTION check_deepgram_rate_limit(
    user_id UUID, 
    endpoint VARCHAR(100), 
    max_requests INTEGER DEFAULT 100,
    window_minutes INTEGER DEFAULT 60
)
RETURNS BOOLEAN AS $$
DECLARE
    current_count INTEGER;
    window_start TIMESTAMPTZ;
BEGIN
    window_start := DATE_TRUNC('hour', NOW()) + 
                   INTERVAL '1 hour' * FLOOR(EXTRACT(MINUTE FROM NOW()) / window_minutes) * (window_minutes / 60.0);
    
    -- Get current count for this window
    SELECT request_count INTO current_count
    FROM deepgram_rate_limits
    WHERE deepgram_rate_limits.user_id = check_deepgram_rate_limit.user_id
      AND deepgram_rate_limits.endpoint = check_deepgram_rate_limit.endpoint
      AND deepgram_rate_limits.window_start = window_start;
    
    -- If no record exists, create one
    IF current_count IS NULL THEN
        INSERT INTO deepgram_rate_limits (user_id, endpoint, window_start, max_requests, window_size_minutes)
        VALUES (user_id, endpoint, window_start, max_requests, window_minutes);
        RETURN TRUE;
    END IF;
    
    -- Check if under limit
    IF current_count < max_requests THEN
        -- Increment counter
        UPDATE deepgram_rate_limits 
        SET request_count = request_count + 1,
            updated_at = NOW()
        WHERE deepgram_rate_limits.user_id = check_deepgram_rate_limit.user_id
          AND deepgram_rate_limits.endpoint = check_deepgram_rate_limit.endpoint
          AND deepgram_rate_limits.window_start = window_start;
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create cleanup function for old rate limit records
CREATE OR REPLACE FUNCTION cleanup_old_rate_limits()
RETURNS VOID AS $$
BEGIN
    DELETE FROM deepgram_rate_limits 
    WHERE created_at < NOW() - INTERVAL '1 day';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;